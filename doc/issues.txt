-----------1、转到cmake版本
-----------2、更改项目名称
3、讲trunk内容吸收过来
4、trunk的文件结构不一定合理。研究其他开源库的结构并改进
-----------5、将boost的东西都藏到cpp中，最终目标：只需要引用wtlib哭就行了，不需要知道背后的库

---------------6、util下序列化功能，考虑使用swap以提高性能


---------------7、process类

----------8、filebase拓展一个prjbase
工程类应该有工程名称、版本、描述等信息
工程路径为文件夹。有工程本体文件
能够管理大量子文件。子文件如果不是绝对路径则为相对于工程本体文件的相对路径
提供日志功能（可选）。日志文件



------------9、filebase提供一个缺省的实现，使用序列化到文件的方法

10、能不用boost库用std库的尽量用std库

11、尽量使用tstring。除非一些必须要使用string的地方（如需要序列化的存储数据的地方）


12、锁、读写锁

13、关于中文的问题和wchar_t的使用需要仔细测试。还有就是什么情况会遇到中文输出？能否尽量避免或是制定规范？

14、尽量做成头文件库

15、杜绝使用原始指针。全部使用智能指针
谨慎运用隐式转换，加上explicit


16、网络日志服务器系统：
功能：
1）一个进程一个单例，线程安全的log接口，字符流风格
2）提供到控制台、到文件、到自定义处理函数（网络适配器到远程服务器）的日志记录
3）debug模式和release模式：release版本时一些等级的日志不需要编译，一些信息（如文件、行数）也不需要显示
4）普通日志等级运行时可修改
5）支持记录到数据库
6）提供全头文件引用方式和动态库+接口引用方式
7）提供一些日志查询接口



组件：
网络适配器，boost.log，简易数据库


17、坚持使用最新技术。库尽量都用最新的，工具版本都用最新的，不必考虑对旧版本兼容（但在发布时需要说明：xx版本开始使用新的xxx，将不保证对旧版本的支持）。工具都尽量用64位的
用cmake建工程，减少vs的耦合性。vs里不需要添加插件也能进行编译

18、网络适配器的一些想法：
因为boost序列化能够支持智能指针
理想的是做一个模板类，数据是一个shared_ptr<const T>，指向一个可以被序列化的类，然后在发送时序列化并发送
shared_ptr<const T> 可以用如下方式生成：
test* p = new test();
std::shared_ptr<const test> testptr(p);
不要delete p 即可
一个shared_ptr<const T>大小为16个字节。因此比这个大小还要小的数据不适合用此方法

如果要去耦合的话就传入shared_ptr<const string>，提前序列化好


