-----------1、转到cmake版本
-----------2、更改项目名称
3、讲trunk内容吸收过来
4、trunk的文件结构不一定合理。研究其他开源库的结构并改进
-----------5、将boost的东西都藏到cpp中，最终目标：只需要引用wtlib哭就行了，不需要知道背后的库

---------------6、util下序列化功能，考虑使用swap以提高性能


---------------7、process类

----------8、filebase拓展一个prjbase
工程类应该有工程名称、版本、描述等信息
工程路径为文件夹。有工程本体文件
能够管理大量子文件。子文件如果不是绝对路径则为相对于工程本体文件的相对路径
提供日志功能（可选）。日志文件



------------9、filebase提供一个缺省的实现，使用序列化到文件的方法

10、能不用boost库用std库的尽量用std库

11、尽量使用tstring。除非一些必须要使用string的地方（如需要序列化的存储数据的地方）


12、锁、读写锁

13、关于中文的问题和wchar_t的使用需要仔细测试。还有就是什么情况会遇到中文输出？能否尽量避免或是制定规范？

14、尽量做成头文件库

15、杜绝使用原始指针。全部使用智能指针
谨慎运用隐式转换，加上explicit


16、网络日志服务器系统：
功能：
1）一个进程一个单例，线程安全的log接口，字符流风格
2）提供到控制台、到文件、到自定义处理函数（网络适配器到远程服务器）的日志记录
3）debug模式和release模式：release版本时一些等级的日志不需要编译，一些信息（如文件、行数）也不需要显示
4）普通日志等级运行时可修改
5）支持记录到数据库
6）提供全头文件引用方式和动态库+接口引用方式
7）提供一些日志查询接口

网络日志：
	实现一个后端类来连接服务器，主要初始化参数为ip和端口
	不能保证连接上。采用异步连接的方式，循环连接（一定时间一次），如果连接上则发送日志，否则什么也不做
	同时本地日志、控制台显示可选
	可以添加多个远程日志服务后端（不同的ip和port）
	日志服务器接收到日志后存入数据库（sqlite3）
	按日期来创建数据库

组件：
网络适配器，boost.log，简易数据库


17、坚持使用最新技术。库尽量都用最新的，工具版本都用最新的，不必考虑对旧版本兼容（但在发布时需要说明：xx版本开始使用新的xxx，将不保证对旧版本的支持）。工具都尽量用64位的
用cmake建工程，减少vs的耦合性。vs里不需要添加插件也能进行编译

18、网络适配器的一些想法：
因为boost序列化能够支持智能指针
理想的是做一个模板类，数据是一个shared_ptr<const T>，指向一个可以被序列化的类，然后在发送时序列化并发送
！！！：可以直接序列化到网络流上吗？
shared_ptr<const T> 可以用如下方式生成：
test* p = new test();
std::shared_ptr<const test> testptr(p);
不要delete p 即可
一个shared_ptr<const T>大小为16个字节。因此比这个大小还要小的数据不适合用此方法
----------------------------------------
还是去掉const吧，因为要能够使接收回掉能够直接使用数据包
保证数据在进入通道后不再更改即可
---------------------------------------------
如果要去耦合的话就传入shared_ptr<const string>，提前序列化好

所以做两种类型：
通用型：发送string
模板型：发送shared_ptr<const T>


但有时还会遇到一个可序列化类+若干string的形式
实际操作时还是根据具体情况具体处理吧

---------------------------------------------
效率最高的果然还是直接序列化到发送流中和直接从接收流中反序列化。string数据统统作为shared_ptr存放在类中

todo：
1、研究boost序列化+boost.asio的tcp传输
2、设计最优包和最优发送接收方式
3、以当前NetAdapterBase设计一个能用的网络适配器
4、以boost.asio为框架重新设计一个高性能网络适配器
